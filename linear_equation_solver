`timescale 1ns/1ps

module linear_equation_solver_3x3 #(
    parameter DATA_WIDTH = 16,
    parameter MAX_ITER = 40
)(
    input wire clk,
    input wire rst,
    input wire start,

    // Matrix A and vector b load interface
    input wire [DATA_WIDTH-1:0] a_data,
    input wire [3:0] a_addr,
    input wire a_wen,
    input wire [DATA_WIDTH-1:0] b_data,
    input wire [1:0] b_addr,
    input wire b_wen,

    // Solution output
    output reg [DATA_WIDTH-1:0] x0, x1, x2,
    output reg done
);

    // Internal storage
    reg [DATA_WIDTH-1:0] A [0:8];
    reg [DATA_WIDTH-1:0] b [0:2];
    reg [DATA_WIDTH-1:0] x [0:2];
    reg [DATA_WIDTH-1:0] x_new [0:2];

    // FSM states
    localparam IDLE = 0, WAIT_LOAD = 1, LOAD_MAT = 2, START_MVMUL = 3, WAIT_MVMUL = 4, UPDATE = 5, OUTPUT = 6, DONE = 7;
    reg [2:0] state;

    integer iter;
    integer i, j;

    // For matrix-vector multiply
    reg mm_start;
    reg [DATA_WIDTH-1:0] mm_a_data, mm_b_data;
    reg [3:0] mm_a_addr, mm_b_addr;
    reg mm_a_wen, mm_b_wen;

    wire [DATA_WIDTH-1:0] mm_c_data;
    wire mm_c_valid;
    wire mm_done;

    // Storage for A*x result
    reg [DATA_WIDTH-1:0] Ax [0:2];
    reg [1:0] Ax_idx;

    // Instantiate matrix_multiplier for 3x3 * 3x1
    matrix_multiplier #(
        .M1(3), .N1(3), .N2(1), .DATA_WIDTH(DATA_WIDTH)
    ) mm (
        .clk(clk), .rst(rst), .start(mm_start),
        .mat_a_data(mm_a_data), .mat_a_addr(mm_a_addr), .mat_a_wen(mm_a_wen),
        .mat_b_data(mm_b_data), .mat_b_addr(mm_b_addr), .mat_b_wen(mm_b_wen),
        .mat_c_data(mm_c_data), .mat_c_valid(mm_c_valid), .done(mm_done)
    );

    // Memory write for A and b
    always @(posedge clk) begin
        if (a_wen)
            A[a_addr] <= a_data;
        if (b_wen)
            b[b_addr] <= b_data;
    end

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= IDLE;
            done  <= 0;
            x0 <= 0; x1 <= 0; x2 <= 0;
            x[0] <= 0; x[1] <= 0; x[2] <= 0;
            x_new[0] <= 0; x_new[1] <= 0; x_new[2] <= 0;
            iter <= 0;
            mm_start <= 0; mm_a_wen <= 0; mm_b_wen <= 0;
            mm_a_addr <= 0; mm_b_addr <= 0;
            Ax_idx <= 0;
        end else begin
            case (state)
                IDLE: begin
                    done <= 0;
                    if (start) begin
                        x[0] <= 0; x[1] <= 0; x[2] <= 0;
                        iter <= 0;
                        state <= WAIT_LOAD;
                    end
                end
                WAIT_LOAD: begin
                    // Wait for testbench to finish loading
                    if (!a_wen && !b_wen) begin
                        state <= LOAD_MAT;
                    end
                end
                LOAD_MAT: begin
                    // Load A and x into matrix_multiplier
                    mm_a_wen <= 1; mm_b_wen <= 1;
                    mm_a_addr <= 0; mm_b_addr <= 0;
                    mm_a_data <= A[0];
                    mm_b_data <= x[0];
                    Ax_idx <= 0;
                    state <= START_MVMUL;
                end
                START_MVMUL: begin
                    // Sequentially load all A and x into multiplier
                    if (mm_a_addr < 8) begin
                        mm_a_addr <= mm_a_addr + 1;
                        mm_a_data <= A[mm_a_addr + 1];
                    end else begin
                        mm_a_wen <= 0;
                    end
                    if (mm_b_addr < 2) begin
                        mm_b_addr <= mm_b_addr + 1;
                        mm_b_data <= x[mm_b_addr + 1];
                    end else begin
                        mm_b_wen <= 0;
                    end
                    if (mm_a_addr == 8 && mm_b_addr == 2) begin
                        mm_start <= 1;
                        state <= WAIT_MVMUL;
                    end
                end
                WAIT_MVMUL: begin
                    mm_start <= 0;
                    if (mm_c_valid) begin
                        Ax[Ax_idx] <= mm_c_data;
                        Ax_idx <= Ax_idx + 1;
                    end
                    if (mm_done) begin
                        Ax_idx <= 0;
                        state <= UPDATE;
                    end
                end
                UPDATE: begin
                    // Jacobi update using A*x result
                    for (i = 0; i < 3; i = i + 1) begin
                        // sum = (A*x)[i] - A[i,i]*x[i] (Q8.8)
                        reg signed [2*DATA_WIDTH-1:0] sum;
                        sum = $signed(Ax[i]) - ($signed(A[i*3+i]) * $signed(x[i]) >>> 8);
                        // num = b[i] - sum (Q8.8)
                        reg signed [2*DATA_WIDTH-1:0] num;
                        num = $signed(b[i]) - sum;
                        // Jacobi update: x_new[i] = (num << 8) / A[i,i] (Q8.8)
                        reg signed [DATA_WIDTH-1:0] denom;
                        denom = $signed(A[i*3+i]);
                        if (denom != 0)
                            x_new[i] <= (num <<< 8) / denom;
                        else
                            x_new[i] <= 0;
                    end
                    x[0] <= x_new[0];
                    x[1] <= x_new[1];
                    x[2] <= x_new[2];
                    iter <= iter + 1;
                    if (iter >= MAX_ITER)
                        state <= OUTPUT;
                    else
                        state <= LOAD_MAT;
                end
                OUTPUT: begin
                    x0 <= x[0];
                    x1 <= x[1];
                    x2 <= x[2];
                    done <= 1;
                    state <= DONE;
                end
                DONE: begin
                    done <= 1;
                end
            endcase
        end
    end

endmodule
