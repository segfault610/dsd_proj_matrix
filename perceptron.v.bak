// perceptron.v
module perceptron #(
    parameter INPUT_SIZE  = 4,   // 4 inputs
    parameter OUTPUT_SIZE = 2,   // 2 outputs
    parameter DATA_WIDTH  = 8
)(
    input  wire                         clk,
    input  wire                         rst,
    input  wire                         start,

    // Input vector (4 elements)
    input  wire signed [DATA_WIDTH-1:0] input_vec [0:INPUT_SIZE-1],

    // Weights flattened: [output0_w0, output0_w1, ..., output1_w0, ...]
    input  wire signed [DATA_WIDTH-1:0] weights [0:INPUT_SIZE*OUTPUT_SIZE-1],

    // Output (2 class scores)
    output reg signed [2*DATA_WIDTH-1:0] output_vec [0:OUTPUT_SIZE-1],
    output reg                          done
);

    integer i, j;
    reg busy;

    // Simple FSM: when start asserted, compute outputs in one cycle (behavioural)
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (i = 0; i < OUTPUT_SIZE; i = i + 1)
                output_vec[i] <= 0;
            done <= 0;
            busy <= 0;
        end else begin
            if (start && !busy) begin
                busy <= 1;
                // compute each output: dot product of input_vec and weights for that output
                for (i = 0; i < OUTPUT_SIZE; i = i + 1) begin
                    // accumulator needs to be wide enough
                    reg signed [2*DATA_WIDTH-1:0] acc;
                    acc = 0;
                    for (j = 0; j < INPUT_SIZE; j = j + 1) begin
                        // index into flattened weights: i*INPUT_SIZE + j
                        acc = acc + $signed(weights[i*INPUT_SIZE + j]) * $signed(input_vec[j]);
                    end
                    output_vec[i] <= acc;
                end
                done <= 1;
            end else begin
                done <= 0;
                if (!start) busy <= 0;
            end
        end
    end

endmodule

