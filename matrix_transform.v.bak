// ============================================================================
// MATRIX TRANSFORM MODULE - 2D Coordinate Transformations
// ============================================================================

module matrix_transform #(
    parameter DATA_WIDTH = 8
)(
    input wire clk,
    input wire rst_n,
    input wire start,
    
    input wire signed [DATA_WIDTH-1:0] x_in,
    input wire signed [DATA_WIDTH-1:0] y_in,
    
    input wire [1:0] transform_type,
    input wire signed [DATA_WIDTH-1:0] param1,
    input wire signed [DATA_WIDTH-1:0] param2,
    
    input wire [2*DATA_WIDTH-1:0] matrix_result,
    input wire matrix_valid,
    
    output reg signed [DATA_WIDTH-1:0] x_out,
    output reg signed [DATA_WIDTH-1:0] y_out,
    output reg [2*DATA_WIDTH-1:0] combined_out,
    output reg transform_valid,
    output reg transform_done
);

    reg signed [DATA_WIDTH-1:0] rotation_matrix [0:8];
    reg signed [DATA_WIDTH-1:0] scale_matrix [0:8];
    reg signed [DATA_WIDTH-1:0] translation_matrix [0:8];
    
    localparam [2:0] IDLE              = 3'd0;
    localparam [2:0] LOAD_TRANSFORM    = 3'd1;
    localparam [2:0] LOAD_INPUT        = 3'd2;
    localparam [2:0] TRIGGER_COMPUTE   = 3'd3;
    localparam [2:0] WAIT_RESULT       = 3'd4;
    localparam [2:0] OUTPUT_XY         = 3'd5;
    
    reg [2:0] state;
    reg signed [DATA_WIDTH-1:0] stored_x, stored_y;
    reg [2*DATA_WIDTH-1:0] x_result, y_result;
    reg [1:0] result_count;
    
    // ===== INITIALIZATION =====
    initial begin
        // Rotation matrix for 45 degrees
        rotation_matrix = 8'sd91;    rotation_matrix = -8'sd91;   rotation_matrix = 8'sd0;
        rotation_matrix = 8'sd91;    rotation_matrix = 8'sd91;    rotation_matrix = 8'sd0;
        rotation_matrix = 8'sd0;     rotation_matrix = 8'sd0;     rotation_matrix = 8'sd1;
        
        // Scale matrix (2x scale)
        scale_matrix = 8'sd2;    scale_matrix = 8'sd0;    scale_matrix = 8'sd0;
        scale_matrix = 8'sd0;    scale_matrix = 8'sd2;    scale_matrix = 8'sd0;
        scale_matrix = 8'sd0;    scale_matrix = 8'sd0;    scale_matrix = 8'sd1;
        
        // Translation matrix (tx=5, ty=10)
        translation_matrix = 8'sd1;    translation_matrix = 8'sd0;    translation_matrix = 8'sd5;
        translation_matrix = 8'sd0;    translation_matrix = 8'sd1;    translation_matrix = 8'sd10;
        translation_matrix = 8'sd0;    translation_matrix = 8'sd0;    translation_matrix = 8'sd1;
    end
    
    // ===== FSM =====
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            x_out <= 0;
            y_out <= 0;
            combined_out <= 0;
            transform_valid <= 0;
            transform_done <= 0;
            stored_x <= 0;
            stored_y <= 0;
            result_count <= 0;
        end
        else begin
            transform_valid <= 0;
            
            case (state)
                IDLE: begin
                    transform_done <= 1'b0;
                    result_count <= 0;
                    if (start) begin
                        state <= LOAD_INPUT;
                    end
                end
                
                LOAD_INPUT: begin
                    stored_x <= x_in;
                    stored_y <= y_in;
                    state <= LOAD_TRANSFORM;
                end
                
                LOAD_TRANSFORM: begin
                    state <= TRIGGER_COMPUTE;
                end
                
                TRIGGER_COMPUTE: begin
                    state <= WAIT_RESULT;
                end
                
                WAIT_RESULT: begin
                    if (matrix_valid) begin
                        if (result_count == 2'd0) begin
                            x_result <= matrix_result;
                            result_count <= 2'd1;
                        end
                        else if (result_count == 2'd1) begin
                            y_result <= matrix_result;
                            result_count <= 2'd2;
                            state <= OUTPUT_XY;
                        end
                    end
                end
                
                OUTPUT_XY: begin
                    x_out <= x_result[DATA_WIDTH-1:0];
                    y_out <= y_result[DATA_WIDTH-1:0];
                    combined_out <= {y_result, x_result};
                    transform_valid <= 1'b1;
                    transform_done <= 1'b1;
                    state <= IDLE;
                end
                
                default: state <= IDLE;
            endcase
        end
    end

endmodule

