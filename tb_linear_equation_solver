`timescale 1ns/1ps

module tb_linear_equation_solver;

    // Parameters
    localparam DATA_WIDTH = 16;
    localparam CLK_PERIOD = 10; // 10 ns clock period

    // Testbench signals
    reg clk;
    reg rst;
    reg start;
    reg [DATA_WIDTH-1:0] a_data;
    reg [3:0] a_addr;
    reg a_wen;
    reg [DATA_WIDTH-1:0] b_data;
    reg [1:0] b_addr;
    reg b_wen;

    wire [DATA_WIDTH-1:0] x0, x1, x2;
    wire done;

    // Instantiate the DUT (Device Under Test)
    linear_equation_solver_3x3 #(
        .DATA_WIDTH(DATA_WIDTH),
        .MAX_ITER(10) // Using default value, can be overridden
    ) dut (
        .clk(clk),
        .rst(rst),
        .start(start),
        .a_data(a_data),
        .a_addr(a_addr),
        .a_wen(a_wen),
        .b_data(b_data),
        .b_addr(b_addr),
        .b_wen(b_wen),
        .x0(x0),
        .x1(x1),
        .x2(x2),
        .done(done)
    );

    // Clock generator
    always begin
        clk = 1'b0;
        #(CLK_PERIOD / 2);
        clk = 1'b1;
        #(CLK_PERIOD / 2);
    end

    // Test sequence
    initial begin
        $display("Starting Testbench...");

        // 1. Initialize all inputs
        rst = 1'b1; // Assert reset
        start = 1'b0;
        a_wen = 1'b0;
        b_wen = 1'b0;
        a_data = 0;
        a_addr = 0;
        b_data = 0;
        b_addr = 0;
        
        // 2. Apply and release reset
        #(CLK_PERIOD * 2);
        rst = 1'b0; // De-assert reset
        $display("Reset released. Loading matrices...");
        #(CLK_PERIOD);

        // 3. Load Matrix A values (with 8-bit fractional part)
        // A = [[4, 1, 1], [1, 3, -1], [1, 1, 5]]
        // Row 0
        a_addr <= 0; a_data <= 4 << 8; a_wen <= 1; @(posedge clk);
        a_addr <= 1; a_data <= 1 << 8; a_wen <= 1; @(posedge clk);
        a_addr <= 2; a_data <= 1 << 8; a_wen <= 1; @(posedge clk);
        // Row 1
        a_addr <= 3; a_data <= 1 << 8; a_wen <= 1; @(posedge clk);
        a_addr <= 4; a_data <= 3 << 8; a_wen <= 1; @(posedge clk);
        a_addr <= 5; a_data <= -1 << 8; a_wen <= 1; @(posedge clk); // Negative number
        // Row 2
        a_addr <= 6; a_data <= 1 << 8; a_wen <= 1; @(posedge clk);
        a_addr <= 7; a_data <= 1 << 8; a_wen <= 1; @(posedge clk);
        a_addr <= 8; a_data <= 5 << 8; a_wen <= 1; @(posedge clk);
        a_wen <= 0; // Disable write for A
        $display("Matrix A loaded.");

        // 4. Load Vector b values (with 8-bit fractional part)
        // b = [8, 1, 17]
        b_addr <= 0; b_data <= 8 << 8; b_wen <= 1; @(posedge clk);
        b_addr <= 1; b_data <= 1 << 8; b_wen <= 1; @(posedge clk);
        b_addr <= 2; b_data <= 17 << 8; b_wen <= 1; @(posedge clk);
        b_wen <= 0; // Disable write for b
        $display("Vector b loaded.");

        // 5. Start the solver
        start <= 1;
        @(posedge clk);
        start <= 0;
        $display("Start signal pulsed. Waiting for 'done'...");

        // 6. Wait for the 'done' signal
        wait (done == 1'b1);
        $display("Solver finished.");
        
        // 7. Display the results
        $display("-----------------------------------------");
        $display("Expected solution (fixed-point): x0=256, x1=256, x2=768");
        $display("Actual solution (fixed-point):   x0=%d, x1=%d, x2=%d", x0, x1, x2);
        
        // Also display the integer-equivalent result
        $display("Actual solution (integer approx): x0=%d, x1=%d, x2=%d", x0 >> 8, x1 >> 8, x2 >> 8);
        $display("-----------------------------------------");

        // 8. End the simulation
        $finish;
    end

endmodule
